<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <title>ESP32 Rope-Bot Controller</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Reset & Base */
      * {
        box-sizing: border-box;
      }
      body {
        font-family: "Inter", sans-serif;
        margin: 0;
        background: linear-gradient(135deg, #1e3c72, #2a5298);
        color: #fff;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        padding: 15px 10px 40px;
      }

      h1 {
        font-size: 1.8rem;
        margin: 15px 0 10px;
        text-align: center;
        user-select: none;
      }

      #statusDisplay {
        padding: 10px 18px;
        border-radius: 10px;
        font-weight: 600;
        margin-bottom: 15px;
        width: 100%;
        max-width: 600px;
        text-align: center;
        user-select: none;
      }

      #statusDisplay.connected {
        background-color: #2ecc71;
        color: #000;
      }

      #statusDisplay.disconnected {
        background-color: #e74c3c;
        color: #fff;
      }

      #statusDisplay.simulator {
        background-color: #f1c40f;
        color: #222;
      }

      #canvasContainer {
        width: 100%;
        max-width: 600px;
        aspect-ratio: 1 / 1;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.35);
        touch-action: none;
        background: #ecf0f1;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
        border-radius: 20px;
        touch-action: none;
      }

      #info {
        max-width: 600px;
        margin-top: 20px;
        background: rgba(255, 255, 255, 0.12);
        padding: 16px 22px;
        border-radius: 14px;
        font-size: 0.95rem;
        width: 100%;
        overflow-x: auto;
        user-select: text;
        line-height: 1.4;
        white-space: pre-wrap;
        word-break: break-word;
      }

      #info div {
        margin-bottom: 6px;
      }

      p {
        margin-top: 18px;
        text-align: center;
        font-size: 0.95rem;
        color: #dcdde1;
        user-select: none;
      }

      @media (max-width: 600px) {
        h1 {
          font-size: 1.4rem;
        }
        #statusDisplay {
          font-size: 0.9rem;
          padding: 8px 14px;
        }
        #info {
          font-size: 0.9rem;
          padding: 14px 18px;
        }
      }
    </style>
  </head>
  <body>
    <h1>ESP32 Rope-Bot Controller</h1>
    <div id="statusDisplay" class="disconnected">ðŸ”´ Not Connected</div>
    <div id="canvasContainer">
      <canvas
        id="canvas"
        width="600"
        height="600"
        aria-label="Rope-Bot controller canvas"
      ></canvas>
    </div>
    <div id="info" aria-live="polite" aria-atomic="true"></div>
    <p>Tap or click on the canvas to set a waypoint.</p>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const statusDisplay = document.getElementById("statusDisplay");
      const infoDiv = document.getElementById("info");

      // Fixed motor positions (top-left and top-right corners)
      const motorLeft = { x: 0, y: 0 };
      let motorRight = { x: 1500, y: 0 };

      let botWidthMM = 279.39;
      let windowWidthMM;
      let windowHeightMM;

      let currentX, currentY;
      let isInitialized = false;
      let isConnected = false;

      let waypoints = [];
      let socket = null;

      // Simulator vars
      let simInterval = null;
      const SIM_SPEED = 4; // mm per frame (~60fps)

      // Scale millimeters to canvas pixels
      function scaleX(mm) {
        return (mm / windowWidthMM) * canvas.width;
      }
      function scaleY(mm) {
        return (mm / windowHeightMM) * canvas.height;
      }

      // Draw the rope-bot and ropes + future path
      function draw() {
        if (!isInitialized) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw ropes
        const ropeLeft = { x: currentX - botWidthMM / 2, y: currentY };
        const ropeRight = { x: currentX + botWidthMM / 2, y: currentY };

        ctx.strokeStyle = "#00d2ff";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(scaleX(motorLeft.x), scaleY(motorLeft.y));
        ctx.lineTo(scaleX(ropeLeft.x), scaleY(ropeLeft.y));
        ctx.moveTo(scaleX(motorRight.x), scaleY(motorRight.y));
        ctx.lineTo(scaleX(ropeRight.x), scaleY(ropeRight.y));
        ctx.stroke();

        // Draw bot ellipse
        ctx.fillStyle = "#e67e22";
        ctx.beginPath();
        ctx.ellipse(
          scaleX(currentX),
          scaleY(currentY),
          scaleX(botWidthMM / 2),
          20,
          0,
          0,
          2 * Math.PI
        );
        ctx.fill();

        // Draw waypoints path with dashed lines
        if (waypoints.length > 0) {
          ctx.strokeStyle = "#8e44ad";
          ctx.setLineDash([6, 6]);
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(scaleX(currentX), scaleY(currentY));
          waypoints.forEach((wp) => ctx.lineTo(scaleX(wp.x), scaleY(wp.y)));
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Draw waypoints circles
        ctx.fillStyle = "#8e44ad";
        waypoints.forEach((wp) => {
          ctx.beginPath();
          ctx.arc(scaleX(wp.x), scaleY(wp.y), 8, 0, 2 * Math.PI);
          ctx.fill();
        });
      }

      // Add waypoint on canvas click/tap
      canvas.addEventListener("pointerdown", (e) => {
        if (!isInitialized) return;

        // Only send if connected or simulator running
        if (!isConnected && !simInterval) return;

        const rect = canvas.getBoundingClientRect();
        const xMM = ((e.clientX - rect.left) / rect.width) * windowWidthMM;
        const yMM = ((e.clientY - rect.top) / rect.height) * windowHeightMM;

        // Clamp x/y to window boundaries & bot width
        const clampedX = Math.min(
          Math.max(botWidthMM / 2, xMM),
          windowWidthMM - botWidthMM / 2
        );
        const clampedY = Math.min(Math.max(0, yMM), windowHeightMM);

        if (isConnected && socket && socket.readyState === WebSocket.OPEN) {
          socket.send(
            JSON.stringify({ type: "waypoint", x: clampedX, y: clampedY })
          );
        }

        // Add locally for both connected & sim mode
        waypoints.push({ x: clampedX, y: clampedY });
        draw();
      });

      // Update the info panel with data object
      function updateInfo(data) {
        const lines = [];
        for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
            let value = data[key];
            // Format waypoints array nicely
            if (key === "waypoints" && Array.isArray(value)) {
              value = value.length ? "\n  " + value.join("\n  ") : "None";
              lines.push(`<div><strong>${key}</strong>:${value}</div>`);
            } else {
              lines.push(`<div><strong>${key}</strong>: ${value}</div>`);
            }
          }
        }
        infoDiv.innerHTML = lines.join("");
      }

      // WebSocket connect & init
      function connect() {
        socket = new WebSocket("ws://" + location.hostname + ":81");

        socket.onopen = () => {
          statusDisplay.className = "connected";
          statusDisplay.textContent = "ðŸŸ¢ Connected to Bot";
          isConnected = true;

          // Prompt for canvas size once connected
          promptWindowSizeAndInit();
        };

        socket.onmessage = (event) => {
          const data = JSON.parse(event.data);
          if (data.type == "info") {
            // Update current position & config from server
            currentX = data.currentX ?? currentX;
            currentY = data.currentY ?? currentY;
            botWidthMM = data.botWidth ?? botWidthMM;
            windowWidthMM = data.windowWidth ?? windowWidthMM;
            windowHeightMM = data.windowHeight ?? windowHeightMM;
            motorRight.x = windowWidthMM;

            updateInfo(data);
          }

          if (data.type === "requestWindowSize") {
            promptWindowSizeAndInit();
            return;
          }

          draw();
        };

        socket.onclose = () => {
          statusDisplay.className = "disconnected";
          statusDisplay.textContent = "ðŸ”´ Not Connected";
          isConnected = false;
          // Start simulator if disconnected
          startSimulator();
        };

        socket.onerror = () => {
          statusDisplay.className = "disconnected";
          statusDisplay.textContent = "ðŸ”´ Connection Error";
          isConnected = false;
          // Start simulator on error
          startSimulator();
        };
      }

      // Prompt user for window size, send init message, start drawing
      function promptWindowSizeAndInit() {
        let widthPrompt = null;
        let heightPrompt = null;

        // Loop prompt until valid numbers entered or cancel
        while (true) {
          widthPrompt = prompt(
            "Enter canvas width in millimeters (e.g. 1500):",
            "1500"
          );
          if (widthPrompt === null) break;
          heightPrompt = prompt(
            "Enter canvas height in millimeters (e.g. 1500):",
            "1500"
          );
          if (heightPrompt === null) break;

          if (
            !isNaN(widthPrompt) &&
            !isNaN(heightPrompt) &&
            parseFloat(widthPrompt) > 0 &&
            parseFloat(heightPrompt) > 0
          ) {
            break;
          }
          alert("Please enter valid positive numbers for width and height.");
        }

        if (!widthPrompt || !heightPrompt) {
          alert("Canvas size is required. Using default 1500mm x 1500mm.");
          windowWidthMM = 1500;
          windowHeightMM = 1500;
        } else {
          windowWidthMM = parseFloat(widthPrompt);
          windowHeightMM = parseFloat(heightPrompt);
        }
        motorRight.x = windowWidthMM;

        // Send init message to ESP32 server
        if (isConnected && socket && socket.readyState === WebSocket.OPEN) {
          socket.send(
            JSON.stringify({
              type: "init",
              width: windowWidthMM,
              height: windowHeightMM,
            })
          );
        }

        isInitialized = true;
        currentX = windowWidthMM / 2;
        currentY = windowHeightMM / 2;

        waypoints = [];
        draw();
      }

      // Simulator mode with smooth waypoint movement
      function startSimulator() {
        statusDisplay.className = "simulator";
        statusDisplay.textContent = "ðŸŸ¡ Simulator Mode";
        isConnected = false;

        promptWindowSizeAndInit();

        if (simInterval) clearInterval(simInterval);
        simInterval = setInterval(() => {
          if (waypoints.length === 0) return;

          const target = waypoints[0];
          const dx = target.x - currentX;
          const dy = target.y - currentY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < SIM_SPEED) {
            currentX = target.x;
            currentY = target.y;
            waypoints.shift();
          } else {
            const ratio = SIM_SPEED / dist;
            currentX += dx * ratio;
            currentY += dy * ratio;
          }

          updateInfo({
            simulator: true,
            botWidth: botWidthMM.toFixed(1),
            currentX: currentX.toFixed(1),
            currentY: currentY.toFixed(1),
            windowWidth: windowWidthMM.toFixed(1),
            windowHeight: windowHeightMM.toFixed(1),
            waypoints: waypoints.map(
              (wp, i) => `#${i + 1}: (${wp.x.toFixed(1)}, ${wp.y.toFixed(1)})`
            ),
          });

          draw();
        }, 16); // ~60fps
      }

      window.onload = () => {
        connect();
      };

      // Cleanup on unload
      window.onbeforeunload = () => {
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.close();
        }
        if (simInterval) {
          clearInterval(simInterval);
        }
      };
    </script>
  </body>
</html>

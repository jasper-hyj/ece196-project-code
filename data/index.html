<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <title>ESP32 Rope-Bot Controller</title>
    <style>
      /* Reset & Base */
      * {
        box-sizing: border-box;
      }
      body {
        font-family: sans-serif;
        margin: 0;
        background: linear-gradient(135deg, #1e3c72, #2a5298);
        color: #fff;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        padding: 15px 10px 40px;
      }

      h1 {
        font-size: 1.8rem;
        margin: 15px 0 10px;
        text-align: center;
        user-select: none;
      }

      #statusDisplay {
        padding: 10px 18px;
        border-radius: 10px;
        font-weight: 600;
        margin-bottom: 15px;
        width: 100%;
        max-width: 600px;
        text-align: center;
        user-select: none;
      }

      #statusDisplay.connected {
        background-color: #2ecc71;
        color: #000;
      }

      #statusDisplay.disconnected {
        background-color: #e74c3c;
        color: #fff;
      }

      #statusDisplay.simulator {
        background-color: #f1c40f;
        color: #222;
      }

      #canvasContainer {
        width: 100%;
        max-width: 600px;
        aspect-ratio: 1 / 1;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.35);
        touch-action: none;
        background: #ecf0f1;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
        border-radius: 20px;
        touch-action: none;
      }

      #info {
        max-width: 600px;
        margin-top: 20px;
        background: rgba(255, 255, 255, 0.12);
        padding: 16px 22px;
        border-radius: 14px;
        font-size: 0.95rem;
        width: 100%;
        overflow-x: auto;
        user-select: text;
        line-height: 1.4;
        white-space: pre-wrap;
        word-break: break-word;
      }

      #info div {
        margin-bottom: 6px;
      }

      p {
        margin-top: 18px;
        text-align: center;
        font-size: 0.95rem;
        color: #dcdde1;
        user-select: none;
      }

      @media (max-width: 600px) {
        h1 {
          font-size: 1.4rem;
        }
        #statusDisplay {
          font-size: 0.9rem;
          padding: 8px 14px;
        }
        #info {
          font-size: 0.9rem;
          padding: 14px 18px;
        }
      }
    </style>
  </head>
  <body>
    <h1>ESP32 Rope-Bot Controller</h1>
    <div id="statusDisplay" class="disconnected">ðŸ”´ Not Connected</div>
    <div id="canvasContainer">
      <canvas
        id="canvas"
        width="600"
        height="600"
        aria-label="Rope-Bot controller canvas"
      ></canvas>
    </div>
    <div id="info" aria-live="polite" aria-atomic="true"></div>
    <p>Tap or click on the canvas to set a waypoint.</p>

    <script>
      class CanvasRenderer {
        constructor(canvas, infoDiv) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
          this.infoDiv = infoDiv;

          this.info = {};

          this.info.botWidth = 279.39;
          this.info.windowWidth = 1500;
          this.info.windowHeight = 1500;
          this.info.accelStepper = {};

          this.info.accelStepper.currentX = this.info.windowWidth / 2;
          this.info.accelStepper.currentY = this.info.windowHeight / 2;
          this.info.accelStepper.waypoints = [];

          const leftX =
            this.info.accelStepper.currentX - this.info.botWidth / 2;

          const rightX =
            this.info.accelStepper.currentX + this.info.botWidth / 2;

          this.info.accelStepper.currentLeft = Math.sqrt(
            Math.pow(leftX, 2) + Math.pow(this.info.accelStepper.currentY, 2)
          );

          this.info.accelStepper.currentRight = Math.sqrt(
            Math.pow(this.info.windowWidth - rightX, 2) +
              Math.pow(this.info.accelStepper.currentY, 2)
          );
        }

        scaleX(mm) {
          return (mm / this.info.windowWidth) * this.canvas.width;
        }

        scaleY(mm) {
          return (mm / this.info.windowHeight) * this.canvas.height;
        }

        drawRope() {
          const ropeLeft = {
            x: this.info.accelStepper.currentX - this.info.botWidth / 2,
            y: this.info.accelStepper.currentY,
          };

          const ropeRight = {
            x: this.info.accelStepper.currentX + this.info.botWidth / 2,
            y: this.info.accelStepper.currentY,
          };

          this.ctx.strokeStyle = "#00d2ff";
          this.ctx.lineWidth = 4;
          this.ctx.beginPath();
          this.ctx.moveTo(0, 0);
          this.ctx.lineTo(this.scaleX(ropeLeft.x), this.scaleY(ropeLeft.y));

          this.ctx.moveTo(this.scaleX(this.info.windowWidth), 0);
          this.ctx.lineTo(this.scaleX(ropeRight.x), this.scaleY(ropeRight.y));
          this.ctx.stroke(); // Draw it to canvas
        }

        drawRopeLengths() {
          const ropeLeft = {
            x: this.info.accelStepper.currentX - this.info.botWidth / 2,
            y: this.info.accelStepper.currentY,
          };

          const ropeRight = {
            x: this.info.accelStepper.currentX + this.info.botWidth / 2,
            y: this.info.accelStepper.currentY,
          };

          this.ctx.fillStyle = "#596363";
          this.ctx.font = "16px sans-serif";
          this.ctx.textAlign = "left";
          this.ctx.textBaseline = "middle";

          const midLeftX = this.scaleX(ropeLeft.x) / 2;
          const midLeftY = this.scaleY(ropeLeft.y) / 2;

          const midRightX =
            this.scaleX(this.info.windowWidth) -
            (this.scaleX(this.info.windowWidth) - this.scaleX(ropeRight.x)) / 2;
          const midRightY = this.scaleY(ropeRight.y) / 2;

          this.ctx.fillText(
            `${this.info.accelStepper.currentLeft.toFixed(1)} mm`,
            midLeftX + 5,
            midLeftY
          );
          this.ctx.fillText(
            `${this.info.accelStepper.currentRight.toFixed(1)} mm`,
            midRightX - 80,
            midRightY
          );
        }

        drawBot() {
          this.ctx.fillStyle = "#e67e22";
          this.ctx.beginPath();
          this.ctx.ellipse(
            this.scaleX(this.info.accelStepper.currentX),
            this.scaleY(this.info.accelStepper.currentY),
            this.scaleX(this.info.botWidth / 2),
            20,
            0,
            0,
            2 * Math.PI
          );
          this.ctx.fill();
        }

        drawWaypoints() {
          if (this.info.accelStepper.waypoints.length > 0) {
            this.ctx.strokeStyle = "#8e44ad";
            this.ctx.setLineDash([6, 6]);
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.moveTo(
              this.scaleX(this.info.accelStepper.currentX),
              this.scaleY(this.info.accelStepper.currentY)
            );
            this.info.accelStepper.waypoints.forEach((wp) =>
              this.ctx.lineTo(this.scaleX(wp.x), this.scaleY(wp.y))
            );
            this.ctx.stroke();
            this.ctx.setLineDash([]);
          }

          this.ctx.fillStyle = "#8e44ad";
          this.info.accelStepper.waypoints.forEach((wp) => {
            this.ctx.beginPath();
            this.ctx.arc(
              this.scaleX(wp.x),
              this.scaleY(wp.y),
              8,
              0,
              2 * Math.PI
            );
            this.ctx.fill();
          });
        }

        draw() {
          // Clean up canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          this.drawRope();

          this.drawRopeLengths();

          this.drawBot();

          this.drawWaypoints();
        }

        updateInfo(data) {
          this.info = data;
          this.infoDiv.innerHTML = `<div><strong>Left Motor Speed</strong> = ${this.info.accelStepper.leftMotorSpeed}</div>
          <div><strong>Right Motor Speed</strong> = ${this.info.accelStepper.rightMotorSpeed}</div>`;
        }
      }

      class RopeBotSimulator {
        constructor(renderer, statusDisplay) {
          this.renderer = renderer;
          this.statusDisplay = statusDisplay;
          this.simInterval = null;
          this.SIM_SPEED = 2.5;
          this.info = {};

          this.waypoints = [];
        }

        start() {
          this.statusDisplay.className = "simulator";
          this.statusDisplay.textContent = "ðŸŸ¡ Simulator Mode";

          if (this.simInterval) clearInterval(this.simInterval);

          this.simInterval = setInterval(() => this.simulate(), 16);
          this.renderer.draw();
        }

        simulate() {
          this.info = this.renderer.info;

          if (this.waypoints.length === 0) return;

          const target = this.waypoints[0];

          const dx = target.x - this.info.accelStepper.currentX;
          const dy = target.y - this.info.accelStepper.currentY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < this.SIM_SPEED) {
            this.info.accelStepper.currentX = target.x;
            this.info.accelStepper.currentY = target.y;
            this.waypoints.shift();
          } else {
            const ratio = this.SIM_SPEED / dist;
            this.info.accelStepper.currentX += dx * ratio;
            this.info.accelStepper.currentY += dy * ratio;
          }

          const leftX =
            this.info.accelStepper.currentX - this.info.botWidth / 2;

          const rightX =
            this.info.accelStepper.currentX + this.info.botWidth / 2;

          this.info.accelStepper.currentLeft = Math.sqrt(
            Math.pow(leftX, 2) + Math.pow(this.info.accelStepper.currentY, 2)
          );

          this.info.accelStepper.currentRight = Math.sqrt(
            Math.pow(this.info.windowWidth - rightX, 2) +
              Math.pow(this.info.accelStepper.currentY, 2)
          );

          this.info.accelStepper.waypoints = this.waypoints;

          this.renderer.updateInfo(this.info);
          this.renderer.draw();
        }

        addWayPoint(clientX, clientY) {
          const rect = this.renderer.canvas.getBoundingClientRect();

          const xMM =
            ((clientX - rect.left) / rect.width) *
            this.renderer.info.windowWidth;

          const yMM =
            ((clientY - rect.top) / rect.height) *
            this.renderer.info.windowHeight;

          const clampedX = Math.min(
            Math.max(this.renderer.info.botWidth / 2, xMM),
            this.renderer.info.windowWidth - this.renderer.info.botWidth / 2
          );

          const clampedY = Math.min(
            Math.max(0, yMM),
            this.renderer.info.windowHeight
          );

          this.waypoints.push({
            x: clampedX,
            y: clampedY,
          });
        }

        stop() {
          if (this.simInterval) clearInterval(this.simInterval);
        }
      }

      class WebSocketHandler {
        constructor(renderer, statusDisplay, simulator) {
          this.renderer = renderer; // Canavs Renderer
          this.statusDisplay = statusDisplay; // Display for connection status
          this.socket = null; // Socket for websocket connection
          this.reconnectTimeout = null; // Timeout timer
          this.reconnectDelay = 2000;
        }

        connect() {
          if (
            this.socket &&
            (this.socket.readyState === WebSocket.OPEN ||
              this.socket.readyState === WebSocket.CONNECTING)
          ) {
            return;
          }

          this.socket = new WebSocket("ws://" + location.hostname + ":81");

          this.socket.onopen = () => {
            if (this.reconnectTimeout) {
              clearTimeout(this.reconnectTimeout);
              this.reconnectDelay = 2000;
              this.reconnectTimeout = null;
            }
            this.statusDisplay.className = "connected";
            this.statusDisplay.textContent = "ðŸŸ¢ Connected to Bot";
          };

          this.socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === "init") {
              this.promptWindowSize();
            } else if (data.type === "info") {
              this.renderer.updateInfo(data);
              this.renderer.draw();
            }
          };

          this.socket.onclose = this.handleDisconnect.bind(this);
          this.socket.onerror = this.handleDisconnect.bind(this);
        }

        handleDisconnect() {
          this.statusDisplay.className = "disconnected";
          this.statusDisplay.textContent = "ðŸ”´ Disconnected - Retrying...";

          if (!this.reconnectTimeout) {
            this.reconnectTimeout = setTimeout(() => {
              this.reconnectTimeout = null;
              this.connect();
              this.reconnectDelay = Math.min(this.reconnectDelay * 2, 30000); // cap at 30s
            }, this.reconnectDelay);
          }
        }

        addWayPoint(clientX, clientY) {
          const rect = this.renderer.canvas.getBoundingClientRect();

          const xMM =
            ((clientX - rect.left) / rect.width) *
            this.renderer.info.windowWidth;

          const yMM =
            ((clientY - rect.top) / rect.height) *
            this.renderer.info.windowHeight;

          const clampedX = Math.min(
            Math.max(this.renderer.info.botWidth / 2, xMM),
            this.renderer.info.windowWidth - this.renderer.info.botWidth / 2
          );

          const clampedY = Math.min(
            Math.max(0, yMM),
            this.renderer.info.windowHeight
          );

          this.socket.send(
            JSON.stringify({
              type: "waypoint",
              x: clampedX,
              y: clampedY,
            })
          );
        }

        promptWindowSize() {
          let width, height;
          while (true) {
            width = prompt(
              "Enter canvas width in millimeters (e.g. 1500):",
              "1500"
            );
            if (width === null) return;
            height = prompt(
              "Enter canvas height in millimeters (e.g. 1500):",
              "1500"
            );
            if (height === null) return;
            if (!isNaN(width) && !isNaN(height) && +width > 0 && +height > 0)
              break;
            alert("Please enter valid positive numbers.");
          }

          if (this.socket.readyState === WebSocket.OPEN) {
            this.socket.send(
              JSON.stringify({
                type: "init",
                windowWidth: width,
                windowHeight: height,
              })
            );
          }
        }
      }

      window.onload = () => {
        const canvas = document.getElementById("canvas");
        const statusDisplay = document.getElementById("statusDisplay");
        const infoDiv = document.getElementById("info");

        const renderer = new CanvasRenderer(canvas, infoDiv);
        const simulator = new RopeBotSimulator(renderer, statusDisplay);
        const wsHandler = new WebSocketHandler(
          renderer,
          statusDisplay,
          simulator
        );

        canvas.addEventListener("pointerdown", (e) => {
          if (location.hostname === "192.168.4.1") {
            wsHandler.addWayPoint(e.clientX, e.clientY);
          } else {
            simulator.addWayPoint(e.clientX, e.clientY);
          }
        });

        if (location.hostname === "192.168.4.1") {
          wsHandler.connect();
        } else {
          simulator.start();
        }

        window.addEventListener("online", () => {
          if (
            !wsHandler.socket ||
            wsHandler.socket.readyState === WebSocket.CLOSED
          ) {
            wsHandler.connect();
          }
        });

        window.onbeforeunload = () => {
          if (
            wsHandler.socket &&
            wsHandler.socket.readyState === WebSocket.OPEN
          ) {
            wsHandler.socket.close();
          }
          simulator.stop();
        };
      };
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <title>ESP32 Rope-Bot Simulator</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: "Inter", sans-serif;
        margin: 0;
        background: linear-gradient(135deg, #1e3c72, #2a5298);
        color: #fff;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        padding: 15px 10px 40px;
      }
      h1 {
        font-size: 1.8rem;
        margin: 15px 0 10px;
        text-align: center;
        user-select: none;
      }
      #statusDisplay {
        padding: 10px 18px;
        border-radius: 10px;
        font-weight: 600;
        margin-bottom: 15px;
        width: 100%;
        max-width: 600px;
        text-align: center;
        user-select: none;
        background-color: #f1c40f;
        color: #222;
      }
      #canvasContainer {
        width: 100%;
        max-width: 600px;
        aspect-ratio: 1 / 1;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.35);
        background: #ecf0f1;
        touch-action: none;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
        border-radius: 20px;
        touch-action: none;
      }
      #info {
        max-width: 600px;
        margin-top: 20px;
        background: rgba(255, 255, 255, 0.12);
        padding: 16px 22px;
        border-radius: 14px;
        font-size: 0.95rem;
        width: 100%;
        overflow-x: auto;
        user-select: text;
        line-height: 1.4;
        white-space: pre-wrap;
        word-break: break-word;
      }
      #info div {
        margin-bottom: 6px;
      }
      p {
        margin-top: 18px;
        text-align: center;
        font-size: 0.95rem;
        color: #dcdde1;
        user-select: none;
      }
      @media (max-width: 600px) {
        h1 {
          font-size: 1.4rem;
        }
        #statusDisplay {
          font-size: 0.9rem;
          padding: 8px 14px;
        }
        #info {
          font-size: 0.9rem;
          padding: 14px 18px;
        }
      }
    </style>
  </head>
  <body>
    <h1>ESP32 Rope-Bot Simulator</h1>
    <div id="statusDisplay">ðŸŸ¡ Simulator Mode</div>
    <div id="canvasContainer">
      <canvas
        id="canvas"
        width="600"
        height="600"
        aria-label="Rope-Bot simulator canvas"
      ></canvas>
    </div>
    <div id="info" aria-live="polite" aria-atomic="true"></div>
    <p>Tap or click on the canvas to set a waypoint.</p>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const statusDisplay = document.getElementById("statusDisplay");
      const infoDiv = document.getElementById("info");

      // Fixed motor positions (top-left and top-right corners)
      const motorLeft = { x: 0, y: 0 };
      let motorRight = { x: 1500, y: 0 };

      let botWidthMM = 279.39;
      let windowWidthMM = 1500;
      let windowHeightMM = 1500;

      let currentX, currentY;
      let isInitialized = false;

      let waypoints = [];

      const SIM_SPEED = 4; // mm per frame (~60fps)

      // Scale millimeters to canvas pixels
      function scaleX(mm) {
        return (mm / windowWidthMM) * canvas.width;
      }
      function scaleY(mm) {
        return (mm / windowHeightMM) * canvas.height;
      }

      function draw() {
        if (!isInitialized) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const ropeLeft = { x: currentX - botWidthMM / 2, y: currentY };
        const ropeRight = { x: currentX + botWidthMM / 2, y: currentY };

        // Calculate rope lengths (distance from motor to rope attachment)
        const ropeLeftLength = Math.sqrt(
          (ropeLeft.x - motorLeft.x) ** 2 + (ropeLeft.y - motorLeft.y) ** 2
        );
        const ropeRightLength = Math.sqrt(
          (ropeRight.x - motorRight.x) ** 2 + (ropeRight.y - motorRight.y) ** 2
        );

        // Draw ropes
        ctx.strokeStyle = "#00d2ff";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(scaleX(motorLeft.x), scaleY(motorLeft.y));
        ctx.lineTo(scaleX(ropeLeft.x), scaleY(ropeLeft.y));
        ctx.moveTo(scaleX(motorRight.x), scaleY(motorRight.y));
        ctx.lineTo(scaleX(ropeRight.x), scaleY(ropeRight.y));
        ctx.stroke();

        // Draw rope length text near each rope (offset a bit for clarity)
        ctx.fillStyle = "#000";
        ctx.font = "16px Inter, sans-serif";
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        // Left rope text position (slightly offset from the midpoint of the left rope)
        const leftTextX = scaleX((motorLeft.x + ropeLeft.x) / 2) + 10;
        const leftTextY = scaleY((motorLeft.y + ropeLeft.y) / 2);
        ctx.fillText(ropeLeftLength.toFixed(0) + " mm", leftTextX, leftTextY);

        // Right rope text position (slightly offset from midpoint of right rope)
        const rightTextX = scaleX((motorRight.x + ropeRight.x) / 2) + 10;
        const rightTextY = scaleY((motorRight.y + ropeRight.y) / 2);
        ctx.fillText(
          ropeRightLength.toFixed(0) + " mm",
          rightTextX,
          rightTextY
        );

        // Draw bot ellipse
        ctx.fillStyle = "#e67e22";
        ctx.beginPath();
        ctx.ellipse(
          scaleX(currentX),
          scaleY(currentY),
          scaleX(botWidthMM / 2),
          20,
          0,
          0,
          2 * Math.PI
        );
        ctx.fill();

        // Draw waypoints and path lines
        if (waypoints.length > 0) {
          ctx.strokeStyle = "#8e44ad";
          ctx.setLineDash([6, 6]);
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(scaleX(currentX), scaleY(currentY));
          waypoints.forEach((wp) => ctx.lineTo(scaleX(wp.x), scaleY(wp.y)));
          ctx.stroke();
          ctx.setLineDash([]);
        }

        ctx.fillStyle = "#8e44ad";
        waypoints.forEach((wp) => {
          ctx.beginPath();
          ctx.arc(scaleX(wp.x), scaleY(wp.y), 8, 0, 2 * Math.PI);
          ctx.fill();
        });
      }

      canvas.addEventListener("pointerdown", (e) => {
        if (!isInitialized) return;

        const rect = canvas.getBoundingClientRect();
        const xMM = ((e.clientX - rect.left) / rect.width) * windowWidthMM;
        const yMM = ((e.clientY - rect.top) / rect.height) * windowHeightMM;

        const clampedX = Math.min(
          Math.max(botWidthMM / 2, xMM),
          windowWidthMM - botWidthMM / 2
        );
        const clampedY = Math.min(Math.max(0, yMM), windowHeightMM);

        waypoints.push({ x: clampedX, y: clampedY });
        draw();
      });

      function updateInfo(data) {
        const lines = [];
        for (const key in data) {
          if (Object.hasOwnProperty.call(data, key)) {
            let value = data[key];
            if (key === "waypoints" && Array.isArray(value)) {
              value = value.length ? "\n  " + value.join("\n  ") : "None";
              lines.push(`<div><strong>${key}</strong>:${value}</div>`);
            } else {
              lines.push(`<div><strong>${key}</strong>: ${value}</div>`);
            }
          }
        }
        infoDiv.innerHTML = lines.join("");
      }

      function promptWindowSizeAndInit() {
        // In Simulator Mode, default to 1500 x 1500 mm without prompt
        windowWidthMM = 1500;
        windowHeightMM = 1500;
        motorRight.x = windowWidthMM;

        isInitialized = true;
        currentX = windowWidthMM / 2;
        currentY = windowHeightMM / 2;

        waypoints = [];
        draw();
      }

      function simulatorLoop() {
        if (waypoints.length === 0) return;

        const target = waypoints[0];
        const dx = target.x - currentX;
        const dy = target.y - currentY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < SIM_SPEED) {
          currentX = target.x;
          currentY = target.y;
          waypoints.shift();
        } else {
          const ratio = SIM_SPEED / dist;
          currentX += dx * ratio;
          currentY += dy * ratio;
        }

        updateInfo({
          simulator: true,
          X: currentX.toFixed(1),
          Y: currentY.toFixed(1),
          waypoints: waypoints.map(
            (wp, i) => `#${i + 1}: (${wp.x.toFixed(1)}, ${wp.y.toFixed(1)})`
          ),
        });

        draw();
      }

      window.onload = () => {
        promptWindowSizeAndInit();
        setInterval(simulatorLoop, 16); // ~60fps
      };
    </script>
  </body>
</html>
